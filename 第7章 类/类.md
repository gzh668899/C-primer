+ 封装和数据抽象
  + 数据抽象是一种接口和实现分离的编程技术
  + 封装实现了类的接口和实现的分离
    + 类的接口包含用户所能执行的操作
    + 类的实现包括类的数据成员，负责接口实现的函数体，定义类所需的各种私有函数

+ 抽象数据类型
  + 类的设计者关注类的实现
  + 类的使用者关注类的接口

+ 定义和声明成员函数
  + 成员函数的声明必须在类的内部
  + 成员函数体可以定义在类内也可以定义在类外
  + 定义在类内部的函数是隐式的inline函数
  
+ 作为接口组成部分的非成员函数
  + 定义和声明都在类的外部

+ this指针
  + string isbn() const { return bookNo; }
  + total.isbn();
  + 当调用成员函数时，实际上是替某个对象调用
  + 成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象
  + 当调用一个成员函数时，用请求该函数的 对象的地址 初始化this
  + total.isbn() === Sales_data::isbn(&total)
  + 调用Sales_data的isbn成员时传入了total的地址
  + 编译器负责将total的地址传递给isbn的隐式形参this
  + 在成员函数内部，可以直接使用 调用该函数的 对象的成员，无须通过成员访问运算符（点运算符或箭头运算符）
    + 即可以直接使用 bookNo ，没必要使用 this->bookNo 或 (*this).bookNo

+ const成员函数（常量成员函数）
  + const的作用是修改隐式this指针的类型
  + this的默认类型是 指向类类型非常量版本（指向Sales_data而不是const Sales_data） 的常量指针：Sales_data *const
  + 默认情况下我们不能在一个常量对象上调用该函数，指针类型需要是 const Sales_data *const
  + C++语言将const关键字放在成员函数参数列表之后 表明 this是一个指向常量的常量指针
  + string isbn() const { return bookNo; } ===  string isbn(const Sales_data *const this) const { return this->bookNo; }
    + isbn可以读取调用它的对象（total）的数据成员（bookNo），但是不能写入新值
  + 常量对象以及常量对象的引用或指针都只能调用常量成员函数

+ 类的作用域和成员函数
  + 类的成员函数的定义嵌套在类的作用域内
  + 编译器分两步处理类
    + 首先编译成员的声明
    + 然后编译成员函数体
    + 成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序
    + 因此哪怕bookNo的定义出现在isbn之后，isbn也还是能够使用bookNo
  + 在类的外部定义成员函数
    + 成员函数的定义必须跟类内部的声明保持一致
    + 如果成员函数是常量成员函数，成员函数的定义也必须在参数列表之后指定const属性
    + 类外部定义的成员函数的名字必须包含它所属的类名（使用作用域运算符）

+ 返回this对象
  + return *this;
  + return语句解引用this指针获得执行该函数的对象
  + 使用this将对象当成一个整体访问，而非直接访问对象的某个成员
  + 例如total.combian(trans)，返回total的引用或拷贝

+ 类的非成员函数
  + IO类型不能被拷贝，只能通过引用传递
  + 读取和写入的操作会改变流的内容，因此使用普通引用而非对常量的引用

+ 构造函数
  + 类通过一个或几个特殊的成员函数控制其对象初始化的过程，这些函数叫做构造函数
  
+ 默认构造函数（合成的默认构造函数）
  + 如果类没有显式的定义构造函数，则使用默认构造函数
  + 默认构造函数无须任何实参
  + 默认构造函数初始化规则
    + 如果存在类内初始值，用它来初始化成员
    + 否则，默认初始化该成员

+ 某些类不能依赖默认构造函数
  + 默认构造函数只适合非常简单的类，对于普通的类来说，必须自己定义默认构造函数
  + 原因1：编译器只有在类没有任何构造函数的情况下才会生成默认构造函数，如果我们定义了其他的构造函数，类将没有默认构造函数
  + 原因2：如果类包含内置类型或复合类型的成员，只有这些类型的成员全都具有类内初始值时（或者自己定义一个构造函数），才适合使用默认构造函数，否则它们的值是未定义的
  + 原因3：如果类中包含类类型的成员，且该成员的类型没有默认构造函数，编译器将无法初始化该成员，编译器无法为这种类生成默认构造函数

+  =default要求编译器生成默认构造函数
  + Sale_data() = default
  + 该函数的作用完全等同于之前使用的合成默认构造函数
  
+ 构造函数初始值列表
  + 构造函数初始值列表负责为新创建的对象的一个或几个数据成员赋初值
  + 构造函数初始值列表是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值
  + 当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化
  + 构造函数不应该轻易覆盖掉类内初始值，除非新赋的值与原值不同
  + 构造函数函数体是空的是因为这些构造函数的唯一目的就是为数据成员赋初值

+ 在类的外部定义构造函数
  + Sales_data::Sales_data() {}
  + 构造函数没有返回类型，上述定义从函数的名字开始
  + 和其它成员函数一样，当在类的外部定义构造函数时，必须指明该构造函数是哪个类的成员

+ 拷贝，赋值，析构
  + 除了定义类的对象如何初始化外，类还需要控制拷贝、赋值、销毁对象时发生的行为
  + 当以值的方式传递或返回一个对象时，会发生对象的拷贝操作
  + 当使用赋值运算符时，会发生对象的赋值操作
  + 当对象不再存在时，会发生对象的销毁操作
    + 比如一个局部对象会在创建它的块结束时被销毁
    + 当vector对象或数组销毁时，存储在其中的对象也会被销毁    
  + 如果不主动定义这些操作，编译器将替我们合成
  + total = trans; 
  + 上述代码编译器的默认赋值操作等价于: 
  + total.bookNo = trans.bookNo；
  + total.units_sold = trans.units_sold;
  + total.revenue = trans.revenue;
  
+ 尽管编译器能替我们合成拷贝、赋值、销毁的操作，但是某些类不能依赖于合成的版本，合成的版本对某些类来说无法正常工作
  + 当类需要分配类对象之外的资源时，合成版本会失效，管理动态内存的类通常不能依赖于上述操作的合成版本
  + 不过很多需要动态内存的类能使用vector对象或者string对象管理必要的存储空间，即如果类包含vector或者string成员，其拷贝、赋值和销毁的合成版本可以正常工作

+ 访问控制和封装
  + 使用访问控制说明符
  + 定义在public说明符后的成员在整个程序内可被访问
  + 定义在private说明符后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问
  + 一个类可以包含0个或多个访问说明符，而且对某个访问说明符能出现几次也没有严格限定
  + 每个访问说明符指定了接下来成员的访问级别，其有效范围直到出现下一个访问说明符或到达类的结尾为止

+ class和struct
  + class和struct的默认访问权限不同
  + 类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类使用class还是struct
  + 如果希望成员是private的,使用class，否则，使用struct

+ 友元
  + 类可以允许其他类或者函数访问它的非公有成员，方法是令其它类或者函数成为它的友元
  + 声明友元只需要在类内部的函数声明的最前方加上friend关键字
  + 友元只能出现在类定义的内部，但是出现在类内的具体位置不限（最好在类定义的开始或结束集中声明）
  + 友元不是类的成员，也不受访问控制的约束
  + 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明
  + 因此除了类内部的友元声明外，还需要在友元声明之外再专门对函数进行一次声明，才能使得类的用户调用友元函数
  + 为了使得友元对类的用户可见，通常将友元的声明与类本身放置在同一个头文件中（类的外部）
 
+ 封装的好处
  + 确保用户代码不会无意间破坏封装对象的状态
  + 被封装的类的具体实现细节可以随时改变，无须调整用户级别的代码

+ 类型成员
  + 除了可以定义数据和函数成员外，类还可以自定义某种类型在类中的别名
  + 由类定义的类型名字也存在访问限制，要么是public，要么是private
  + 用来定义类型的成员必须先定义再使用，类型成员通常出现在类开始的地方

+ 令成员函数作为内联函数
  + 定义在类内部的成员函数是自动inline的
  + 也可以在类的内部把inline作为声明的一部分显式地声明成员函数
  + 也可以在类的外部用inline修饰函数的定义
  + 没必要在声明和定义的地方同时说明inline，虽然合法，但是最好只在类外部定义的地方说明inline,更好理解
  + 与inline函数要定义在头文件中一样的原因，inline成员函数应该与相应的类定义在同一个头文件中

+ 成员函数也可以被重载
  + 只要函数之间在参数的数量或参数的类型上有区别就行
  
+ 可变数据成员
  + 如果想要修改类的某个数据成员，即使在一个const成员函数里
  + 可以通过在变量的声明中加入mutable关键字实现
  + 一个可变数据成员永远不会是const, 即使它是const对象的成员
  + 一个const成员函数可以改变一个可变成员的值

+ 类内初始值
  + 类内初始值必须使用=的初始化形式或者用花括号括起来的初始化形式

+ 返回*this的成员函数
  + 一个成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用

+ 基于const的重载
  + 通过区分成员函数是否是const的，可以对其进行重载
    + 因为非常量版本的函数对于常量对象是不可用的
    + 另外因为虽然可以在非常量对象上调用常量版本或非常量版本，但非常量版本是更好的

+ 类类型
  + 每个类定义了唯一的类型
  + 即使两个类成员完全一样，这两个类也是不同的类型
  
+ 类的声明
  + 可以仅仅声明类，暂时不定义它
  + 在类的声明之后，定义之前，类是一个不完全类型
  + 不完全类型只能在非常有限的场景下使用
    + 可以定义指向这种类型的指针或引用
    + 可以声明，但是不能定义以不完全类型作为参数或者返回类型的函数
  + 创建类的对象之前类必须被定义过，否则编译器无法了解该类的对象需要多少存储空间
  + 类必须先被定义，才可使用引用或指针访问其成员
  + 只有类被定义之后数据成员才可声明成这种类类型
  + 但是类的数据成员可声明为指向自身类型的引用或指针

+ 友元
  + 类可以将非成员函数定义为友元
  + 类也可以将其它类定义为友元
  + 类还可以将其它类的成员函数定义为友元

+ 友元类
  + 如果某个类指定了友元类，那么友元类的成员函数可以访问此类包括非共有成员在内的所有成员
  + 友元关系不具有传递性
  
+ 成员函数作为友元
  + 必须按照正确的程序组织方式设计程序
  + 当把一个成员函数声明为友元时，必须指出该成员函数属于哪一个类

+ 重载函数作为友元
  + 如果一个类想把一组重载函数声明为它的友元，必须对这组函数的每一个进行分别声明

+ 友元声明和作用域
  + 哪怕在类的内部定义友元，也需要在外部提供相应的声明使得函数可见

+ 类的作用域
  + 每个类具有自己的定义域
  + 在类的定义域之外，普通的数据和函数成员只能由对象、对象的引用或者指针使用成员访问运算符来访问
  + 在类的定义域之外，类类型成员，使用作用域运算符访问
  + 在类的外部定义成员函数时，必须同时提供类名和函数名
  + 由于类名被定义在函数名之前，因此函数名后面的参数列表和函数体在类的作用域之内，在参数列表和函数体中可以直接使用类的成员而不需要加类名
  + 由于函数的返回类型出现在函数名之前，当成员函数定义在类的外部时，返回类型使用的名字在类的作用域之外，因此当成员函数定义在类的外部时，返回类型必须指明它是哪个类的成员

+ 名字查找与类的作用域
  + 名字查找：在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明，如果没有找到，继续查找外层作用域
  + 在类中的名字查找与上述的名字查找有所区别，首先会编译成员的声明，直到类全部可见后才编译函数体
  + 因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字
  + 在类的内层作用域不可重新定义外层作用域中的名字（当这个名字代表某个类型时）


## 第九章 顺序容器

### 1、顺序容器概述

容器：特定类型对象的集合

容器类型：顺序容器，关联容器，容器适配器



顺序容器：**vector，string，list，forward_list，deque，array**

| 容器类型       | 介绍                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。    |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快。 |
| `forward_list` | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或者删除元素。       |
| `string`       | 与`vector`相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 |



**array：**固定大小数组

**vector：**可变大小数组

**string：**可变大小数组（保存字符）

**forward_list：**单向链表

**list：**双向链表

**deque：**双端队列



**vector和string**

①支持随机访问 

②尾部插入/删除速度快 

③中间位置插入/删除速度慢



**list和forward_list** 

①不支持随机访问，只支持顺序访问，访问访问某个元素，必须遍历整个容器 

②list双向顺序访问，forward_list单向顺序访问

③forward_list没有size操作，因为size操作会增加开销

③任何位置插入/删除元素速度都很快

④**额外内存开销大**



**deque**

①支持随机访问

②头部和尾部插入/删除速度快



**array**

①支持随机访问

②不能添加/删除元素

③不能改变容器大小



### 2、容器库概览

每个容器都定义在一个头文件中，文件名与类型名相同

vector保存在头文件vector中 

```c++
#include <vector>
```

string保存在头文件string中

```c++
#include <string>
```



+ 容器均定义为模板类，需要提供额外的信息生成特定的容器类型

+ 容器可以保存任何类型，包括容器     

+ 但是有些容器操作对元素类型有特殊要求



#### 1、迭代器

+ 通过解引用访问容器中的元素
    + begin()，end()
        + 如果容器为空，beigin和end返回同一个迭代器，都是尾后迭代器
    + *iter：返回迭代器iter所指元素的引用
    + **iter->mem：等价于(*iter).mem（必须带着括号）**，解引用iter，并返回该元素名为mem的成员
    + ++iter：令iter指向容器中的下一个元素
        + iter + n
        + iter += n
    + --iter：令iter指向容器中的前一个元素
        + forward_list迭代器不支持递减运算符
        + iter - n
        + iter -= n
    + iter1 - iter2 ：两个迭代器的距离，右侧的迭代器向前移动多少位置可以追上左侧的迭代器
        + 类型difference_type，带符号类型，距离可正可负
    + iter1 == iter2，iter1 != iter2 判断两个迭代器是否相等
        + 尽量使用!=判断，而不是<判断，因为有一些容器迭代器没有定义<运算符
+ 迭代器类型
    + vector<int>::iterator
    + vector<int>::const_iterator：能读取但不能修改它所指的元素的值

+ begin()和end()
    + 如果对象是常量，返回const_iterator，对象不是常量，返回iterator
    +  cbegin()，cend()，无论对象是不是常量，返回const_iterator



#### 2、容器操作

| 操作              | 解释                                               |
| :---------------- | -------------------------------------------------- |
| `iterator`        | 此容器类型的迭代器类型                             |
| `const_iterator`  | 可以读取元素但不能修改元素的迭代器类型             |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离       |
| `value_type`      | 元素类型                                           |
| `reference`       | 元素的左值类型；和`value_type &`含义相同           |
| `const_reference` | 元素的`const`左值类型，即`const value_type &`      |



#### 3、容器的定义和初始化

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `C c;`                    | 默认构造函数，构造空容器                                     |
| `C c1(c2);`或`C c1 = c2;` | 构造`c2`的拷贝`c1`                                           |
| `C c(b, e)`               | 构造`c`，将迭代器`b`和`e`指定范围内的所有元素拷贝到`c`       |
| `C c{a, b, c...}`；       | 列表初始化`c`                                                |
| `C seq(n)`                | 只支持顺序容器，且不包括`array`，包含`n`个元素，这些元素进行了值初始化 |
| `C seq(n, t)`             | 包含`n`个初始值为`t`的元素                                   |

+ 每个容器都有默认构造函数
+ 进行一个容器到另一个容器的拷贝时，两个容器的类型及元素类型必须匹配
+ 传递迭代器参数拷贝一个范围时候，不要求容器类型和元素类型相同，只要能将要拷贝的容器元素转换为要初始化的容器的元素类型即可，本质上是一个个的进行转换然后拷贝
+ 只有顺序容器的构造函数才接受大小参数，关联容器不支持





**定义标准库array时，除了指定元素类型，还要指定容器大小，大小是array类型的一部分**

array<int, 42>



内置数组不支持拷贝或对象赋值操作，array没有限制

array要求初始值的类型与容器类型相同





#### 4、赋值和swap

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c1 = c2;`          | 将`c1`中的元素替换成`c2`中的元素                             |
| `c1 = {a, b, c...}` | 将`c1`中的元素替换成列表中的元素（不适用于`array`）          |
| `c1.swap(c2)`       | 交换`c1`和`c2`的元素                                         |
| `swap(c1, c2)`      | 等价于`c1.swap(c2)`                                          |
| `c.assign(b, e)`    | 将`c`中的元素替换成迭代器`b`和`e`表示范围中的元素，`b`和`e`不能指向`c`中的元素 |
| `c.assign(il)`      | 将`c`中的元素替换成初始化列表`il`中的元素                    |
| `c.assign(n, r)`    | 将`c`中的元素替换为`n`个值是`t`的元素                        |



赋值运算会导致指向左边容器内部的迭代器，引用和指针失效

swap不会导致指向容器的迭代器，引用和指针失效（array，string除外）



assign

+ assign不适用于关联容器和array，仅适用于顺序容器
+ assign允许不同但是相容的类型赋值



swap

+ 元素本身并未交换，swap只是交换了两个容器的内部数据结构

+ 指向容器的迭代器，指针和引用不会失效，因为元素没有被移动

+ swap两个array会真正交换它们的元素，交换两个array的时间与array中元素的数目成正比

+ 对string调用swap会导致指向容器的迭代器，指针和引用失效

+ swap有成员函数版本和非成员版本，使用非成员版本的swap是个好习惯

    ![](https://gzh-typorapictures.oss-cn-beijing.aliyuncs.com/image/20220422152713.png)



array的赋值

+ array类型允许赋值，跟内置数组不同
+ 赋值号的左右两边对象要有相同的类型
+ 由于右侧运算对象的大小可能与左侧运算对象的大小不同，array不支持assign
+ array也不允许用花括号包围的值列表进行赋值



#### 5.容器大小操作

| 操作           | 解释                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目（不支持`forward_list`）        |
| `c.max_size()` | `c`中可保存的最大元素数目                      |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |



#### 6.容器的关系运算

==，!=，>，>=，<，<=

+ 比较两个容器实际上是进行元素的逐对比较，和string的关系运算类似

+ 容器的比较是通过元素的比较实现的，如果元素不支持比较，容器就不能比较，比如Sales_data元素





### 3、顺序容器操作



#### 1、添加元素

**向vector，string，deque插入元素会使所有指向容器的迭代器，引用和指针失效**

（因为插入元素可能会需要扩容，扩容的过程要释放旧空间使用新空间，如果没有给迭代器重新赋值，那迭代器还指向已经被释放掉的旧空间，就会导致迭代器失效）



**①push_back()**（顺序容器尾部添加元素）

+ vector，string，deque，list支持

+ forward_list不支持

（forward_list是单向链表，想要访问尾元素，要从首元素开始迭代，算法复杂度O（n），因此不支持）

+ 返回void



**②push_front()**（顺序容器头部添加元素）

+ list，forward_list，deque支持

+ vector，string不支持

+ 返回void



**③insert()**（任意位置添加元素）

+ vector，string，deque，list支持，forward_list有自己独有的特殊版本insert

+ 接受一个迭代器作为第一个参数

+ 迭代器可以指向容器中任何位置，包括容器尾部之后的下一个位置

+ insert将元素插入到迭代器所指定的位置之前

+ c.insert(p，t)：在迭代器p指向的元素之前插入一个值为t的元素

+ c.insert(p，n，t)：在迭代器p指向的元素之前插入n个值为t的元素

+ c.insert(p，b，e)：将迭代器b和迭代器e指定范围内的元素插入迭代器p指向的元素之前，**但是b和e不能指向容器c中的元素，insert(a.begin()，a.begin()，a.end())是错误的**

+ c.insert(p，il)：il是花括号包围的元素值列表，将列表插入到迭代器p指向的元素之前

+ **返回指向 插入元素中第一个元素 的迭代器**




**④emplace()**

**emplace_front()**

**emplace_back()**



emplace将参数传递给**元素类型的构造函数**，在容器管理的内存空间中直接构造元素

push和insert则是创建一个局部临时对象，将其压入容器



传递给emplace函数的参数必须与元素类型的构造函数相匹配





#### 2、访问元素

**①front()**

+ 返回容器首元素的**引用**，容器不能为空



**②back()**

+ 返回容器尾元素的**引用**，容器不能为空

+ forward_list不支持back()



**c[n]**

**c.at(n)**

+  返回c中下标为n的元素的**引用**

+ **list**和**forward_list**不支持

+ 如果下标越界，at可以抛出一个out_of_range异常





#### 3、删除元素



**①pop_back()**（删除容器尾元素）

+ 返回void

+ vector，string，deque，list支持

+ forward_list不支持



**②pop_front()**（删除容器首元素）

+ 返回void

+ list，forward_list，deque支持

+ vector，string不支持



**③erase()**（删除容器内部元素）

+ **erase(p)**：删除迭代器p所指定的元素，返回指向被删元素之后元素的迭代器，**若p指向尾元素，返回尾后迭代器，若p是尾后迭代器，则函数行为未定义**
+ **erase(b，e)**：删除迭代器b和e所指定范围内的元素，**不包含e**，返回指向最后一个被删元素之后元素的迭代器，**若e本身是尾后迭代器，则函数返回尾后迭代器**



**④clear()**

+ 删除所有元素
+ 返回void

+ 等价于c.erase(c.begin()，c.end())





#### 4、forward_list特殊操作

**①首前迭代器before_begin()，cbefore_begin()**

+ 返回指向链表首元素之前不存在的元素的迭代器，该迭代器不能解引用
+ cbefore_begin（）返回const_iterator



**②insert_after()**（在迭代器p之后的位置插入元素）

+ insert_after(p，t)：p是迭代器，t是对象
+ insert_after(p，n，t)：n是数量
+ insert_after(p，b，e)：b和e是表示范围的迭代器
+ insert_after(p，il)：il是花括号列表
+ 返回指向最后一个插入元素的迭代器
+ 若p是尾后迭代器，函数行为未定义



**③emplace_after()**

+ emplace_after(p，args)：使用args在p指向的位置之后创建一个元素
+ 若p是尾后迭代器，函数行为未定义



**④erase_after()**

+ erase_after(p)：删除p指向位置之后的元素
+ erase_after(b，e)：删除b到e之间的元素，**不包含e**
+ 返回指向被删元素之后元素的迭代器
+ 若p指向尾元素，或者p是一个尾后迭代器，函数行为未定义





#### 5、改变容器大小



**①c.resize(n)**

+ 调整c的大小为n个元素，如果n<c.size()，多出的元素被丢弃，n>c.size()，新元素要进行初始化
+ 不指认参数，将默认初始化



**②c.resize(n，t)**

+ 调整c的大小为n个元素
+ 新添加的元素初始化为值t





#### 6.容器操作可能使得迭代器失效

①添加元素

+ vector和string
    + 如果添加元素后存储空间重新分配
        + 则指向容器的迭代器，指针和引用都会失效
    + 如果添加元素后存储空间未重新分配
        + 指向插入位置之前的元素的迭代器，指针和引用仍有效
        + 指向插入位置之后元素的迭代器，指针和引用将会失效
+ deque
    + 首尾位置添加元素
        + 迭代器会失效
        + 指向元素的指针和引用不会失效
    + 除了首尾位置的其它位置添加元素
        + 迭代器，指针，引用均失效
+ list和forward_list
    + 指向容器的迭代器（包括首前迭代器和尾后迭代器），指针，引用均仍有效



②删除元素

+ vector和string
    + 指向被删元素之前元素的迭代器，指针和引用仍有效
    + 指向被删元素之后元素的迭代器，指针和引用将会失效
+ deque
    + 删除首尾元素
        + 尾后迭代器失效
        + 其它迭代器，引用和指针不受影响
    + 除了首尾位置的其它位置删除元素
        + 迭代器，指针，引用均失效
+ list和forward_list
    + 指向容器的迭代器（包括首前迭代器和尾后迭代器），指针，引用均仍有效



**当删除元素时，尾后迭代器总是会失效**



**不要缓存end返回的迭代器，因为添加/删除元素之后，end返回的迭代器总是会失效**



### 4、vector对象是如何增长的



容器分配新的内存空间——>将已有元素从旧位置移动到新空间——>添加新元素——>释放旧存储空间

如果每添加一个元素，进行一次这样的内存分配和释放操作，性能会慢到不可接受



#### 管理容量的成员函数

| 操作                | 解释                                          |
| ------------------- | --------------------------------------------- |
| `c.shrink_to_fit()` | 将`capacity()`减少到和`size()`相同大小        |
| `c.capacity()`      | 不重新分配内存空间的话，`c`可以保存多少个元素 |
| `c.reverse(n)`      | 分配至少能容纳`n`个元素的内存空间             |

- `shrink_to_fit`只适用于`vector`、`string`和`deque`
- `capacity`和`reverse`只适用于`vector`和`string`。

+ shrink_to_fit只是一个请求，标准库并不保证退还内存

+ vector每次需要分配新的内存空间时，将容量翻倍

+ 理解size和capacity的区别十分重要，size是元素的数目，capacity是容器的容量

+ resize也是只改变元素的数目，不改变容器的容量

    

### 5、额外的string操作

#### 1、构造string的其它方法

| 操作                       | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `string s(cp, n)`          | `s`是`cp`指向的数组中前`n`个字符的拷贝，此数组至少应该包含n个字符 |
| `string s(s2, pos2)`       | `s`是`string s2`从下标`pos2`开始的字符的拷贝。若`pos2 > s2.size()`，则构造函数的行为未定义。 |
| `string s(s2, pos2, len2)` | `s`是`string s2`从下标`pos2`开始的`len2`个字符的拷贝。若`pos2 > s2.size()`，则构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。 |

+ n，len2，pos2都是无符号值

+ 这些构造函数接受一个string或一个const char*参数，还接受可拷贝的多少个字符的参数

+ 从一个const char*创建string时

    + 指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止

    + 如果还传递给拷贝函数一个计数值，数组不必以空字符结尾
    + 如果未传递计数值，或数组未以空字符结尾，或给定计数值大于数组大小，则构造函数的行为未定义

+ 从一个string拷贝字符时

    + 提供一个开始位置和一个计数值
    + 开始位置必须小于等于string的大小，如果位置大于size，会抛出out_of_range异常
    + 传递的计数值无论多大，最多拷贝到string结尾




#### 2、substr操作

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `s.substr(pos, n)` | 返回一个`string`，包含`s`中从`pos`开始的`n`个字符的拷贝。`pos`的默认值是0，`n`的默认值是`s.size() - pos`，即拷贝从`pos`开始的所有字符。 |

+ substr返回一个string，它是原始string的一部分或全部的拷贝
+ 可以传递给substr一个开始位置和计数值
+ 开始位置必须小于等于string的大小，如果位置大于size，会抛出out_of_range异常
+ 传递的计数值无论多大，最多拷贝到string结尾



#### 3、改变srting的其它方法

| 操作                     | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s.insert(pos, args)`    | 在`pos`之前插入`args`指定的字符。`pos`可以使是下标或者迭代器。接受下标的版本返回指向`s`的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 |
| `s.erase(pos, len)`      | 删除从`pos`开始的`len`个字符，如果`len`被省略，则删除后面所有字符，返回指向`s`的引用。 |
| `s.assign(args)`         | 将`s`中的字符替换成`args`指定的字符。返回一个指向`s`的引用。 |
| `s.append(args)`         | 将`args`指定的字符追加到`s`，返回一个指向`s`的引用。         |
| `s.replace(range, args)` | 删除`s`中范围`range`中的字符，替换成`args`指定的字符。range是一个下标和一个长度，或者是一对执行s的迭代器，返回一个指向`s`的引用。 |

![](https://gzh-typorapictures.oss-cn-beijing.aliyuncs.com/image/20220427114213.png)

![](https://gzh-typorapictures.oss-cn-beijing.aliyuncs.com/image/20220427114444.png)



#### 4、string的搜索操作

- `string`类提供了6个不同的搜索函数，每个函数都有4个重载版本。
- 每个搜索操作都返回一个`string::size_type`值，表示匹配发生位置的下标。如果搜索失败则返回一个名为`string::npos`的`static`成员（类型是`string::size_type`，初始化值是-1

| 搜索操作                    | 解释                                              |
| --------------------------- | ------------------------------------------------- |
| `s.find(args)`              | 查找`s`中`args`第一次出现的位置                   |
| `s.rfind(args)`             | 查找`s`中`args`最后一次出现的位置                 |
| `s.find_first_of(args)`     | 在`s`中查找`args`中任何一个字符第一次出现的位置   |
| `s.find_last_of(args)`      | 在`s`中查找`args`中任何一个字符最后一次出现的位置 |
| `s.find_first_not_of(args)` | 在`s`中查找第一个不在`args`中的字符               |
| `s.find_first_not_of(args)` | 在`s`中查找最后一个不在`args`中的字符             |

![](https://gzh-typorapictures.oss-cn-beijing.aliyuncs.com/image/20220428120527.png)

#### 5、string的compare函数

类似于C标准库的`strcmp`函数，`s`等于、大于还是小于参数指定的字符串，`s.compare`返回0、正数或负数。

| 参数形式                 | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s2`                     | 比较`s`和`s2`                                                |
| `pos1, n1, s2`           | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `pos1, n1, s2, pos2, n2` | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `cp`                     | 比较`s`和`cp`指向的以空字符结尾的字符数组                    |
| `pos1, n1, cp`           | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的以空字符结尾的字符数组 |
| `pos1, n1, cp, n2`       | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的地址开始`n2`个字符 |

#### 6、string和数值转换

| 转换              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `to_string(val)`  | 一组重载函数，返回数值`val`的`string`表示。`val`可以使任何算术类型。对每个浮点类型和`int`或更大的整型，都有相应版本的`to_string()`。和往常一样，小整型会被提升。 |
| `stoi(s, p, b)`   | 返回`s`起始子串（表示整数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0，`b`是转换所用的基数，默认为10。返回`int` |
| `stol(s, p, b)`   | 返回`long`                                                   |
| `stoul(s, p, b)`  | 返回`unsigned long`                                          |
| `stoll(s, p, b)`  | 返回`long long`                                              |
| `stoull(s, p, b)` | 返回`unsigned long long`                                     |
| `stof(s, p)`      | 返回`s`起始子串（表示浮点数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0。返回`float` |
| `stod(s, p)`      | 返回`double`                                                 |
| `stold(s, p)`     | 返回`long double`                                            |



### 6、容器适配器（adaptor）

+ 适配器是标准库中的一个通用概念，容器、迭代器和函数都有适配器
+ 本质上，适配器是一种机制，能使一种事物的行为看起来像另外一种事物一样
+ 例如`stack`可以使任何一种顺序容器以栈的方式工作（除了array和forward_list）



#### 容器适配器通用操作类型

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `size_type`      | 一种类型，须以保存当前类型的最大对象的大小                   |
| `value_type`     | 元素类型                                                     |
| `container_type` | 实现适配器的底层容器类型                                     |
| `A a;`           | 创建一个名为`a`的空适配器                                    |
| `A a(c)`         | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝               |
| 关系运算符       | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、 `<=`、`>`、`>=`这些运算符返回底层容器的比较结果 |
| `a.empty()`      | 若`a`包含任何元素，返回`false`;否则返回`true`                |
| `a.size()`       | 返回`a`中的元素数目                                          |
| `swap(a, b)`     | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |
| `a.swap(b)`      | 同上                                                         |



+ 每个适配器都定义了两个构造函数
    + 默认构造函数创建一个空对象
    + 接受一个容器的构造函数拷贝该容器来初始化适配器
        + 例如首先定义一个容器deque<int> deq;
        + 再用该容器初始化stack：stack<int> stk(deq); 



+ 默认情况下，stack和queue是基于deque实现的
+ priority_queue是基于vector实现的



+ 我们可以创建一个适配器，将一个命名的顺序容器作为第二个类型参数，重载默认容器类型

    + stack<string，vector<string> > str_stk（在vector上实现的空栈）

        

+ 适配器不能构造在array上，因为所有适配器要求容器具有添加和删除元素的能力
+ 适配器也不能构造在forward_list上
+ stack要求push_back，pop_back，back操作，可以用除了array，forward_list之外的任何容器类型构造
+ queue要求back，push_back，front，push_front，可以构造在list或deque上，不能基于vecor构造
+ priority_queue要求front，push_back，pop_back，随机访问能力，可以构造在vector和deque上，不能基于list构造



#### 栈适配器

| 操作              | 解释                                                     |
| ----------------- | -------------------------------------------------------- |
| `s.pop()`         | 删除栈顶元素，不返回。                                   |
| `s.push(item)`    | 创建一个新元素，压入栈顶，该元素通过拷贝或移动`item`而来 |
| `s.emplace(args)` | 同上，但元素由`args`来构造。                             |
| `s.top()`         | 返回栈顶元素，但不将元素弹出栈                           |

- 定义在`stack`头文件中。
- `stack`默认基于`deque`实现，也可以在`list`或`vector`之上实现。
- 每个适配器都基于底层容器类型的操作定义了自己的特殊操作
- 我们只可以使用适配器操作，不能使用底层容器类型的操作



#### 队列适配器

| 操作              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `q.pop()`         | 返回queue的队首元素或priority_queue最高优先级的元素，但不删除 |
| `q.front()`       | 返回队首元素的值，不删除。                                   |
| `q.back()`        | 返回队尾元素的值，不删除。只适用于`queue`                    |
| `q.top()`         | 返回具有最高优先级的元素值，不删除。只适用于`priority_queue` |
| `q.push(item)`    | 在queue队尾或priority中恰当的位置创造一个元素                |
| `q.emplace(args)` | 其值为item，或者由args构造                                   |

- 定义在`queue`头文件中。
- `queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现。
- `queue`可以在`list`或`vector`之上实现，`priority_queue`也可以用`deque`实现。

## 第十章 泛型算法



#### 1、概述

标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器，也就是说这些算法是通用的或者泛型的（generic）：它们可用于不同类型的容器和不同类型的元素



+ 大多数算法定义在头文件**algorithm**中
+ 少部分**数值泛型算法**定义在头文件**numeric**中
+ 一般情况下，算法并不直接操作容器，而是遍历两个迭代器指定的一个元素范围进行操作
+ **迭代器令算法不依赖于容器**
+ **但是算法依赖于元素类型的操作**（例如需要元素支持>或者<这种比较运算符，但是大多数算法提供了一种方法，允许我们使用自定义的操作代替默认的运算符）
+ **算法永远不会执行容器的操作，它们只运行在迭代器之上，执行迭代器的操作**

+ **算法因为不会执行容器的操作，所以算法永远不会改变底层容器的大小，算法不会直接添加或删除元素**

+ 标准库定义了一种特殊的迭代器，称为插入器（inserter），算法通过操作这种迭代器来进行像容器中添加元素的操作，但是算法自身不会做这种操作



#### 2、初识泛型算法



+ 大部分算法是对一个范围内的元素进行操作，将范围称为 “输入范围”

+ 接受输入范围的算法使用前两个参数来表示此范围，两个参数分别是指向第一个元素和尾元素之后的迭代器



##### 1、只读算法

+ 只读算法只会读取输入范围内的元素，而不改变输入范围内的元素

+ find算法是只读算法

+ conut算法是只读算法

+ accumulate算法是只读算法

    + accumulate定义在头文件numeric中

    + 接受三个参数

    + 前两个参数指出需要求和的元素范围

    + 第三个参数指出和的初值

    + 第三个参数的类型决定函数使用哪个加法运算符以及返回值的类型

    + 例如：int sum = accumulate(vec.cbegin()，vec.cend()，0)

        

+ 对于只读取而不改变元素的算法，最好使用cbegin()和cend()

+ 不过如果计划使用算法返回的迭代器来改变元素的值，需要使用begin()和end()作为参数



+ equal算法是只读算法

    + 该算法用于确定两个序列是否保存相同的值

    + equal算法将第一个序列中的每个元素与第二个序列中的对应元素进行比较

    + 如果所有元素都相等，返回true，否则返回false

    + 接受三个迭代器参数
    + 前两个参数表示第一个序列中的元素范围
    + 第三个参数表示第二个序列的首元素
    + 例如：equal(roster1.cbegin()，roster1.cend()，roster2.cbegin())

    + 由于equal调用迭代器完成操作，我们可以调用equal比较两个不同类型的容器中的元素，元素类型也不必相同，只要能使用**==运算符**进行比较即可
    + 例如：roster1是vector<string>，roster2是list<const char*>

    + equal算法有一个非常重要的假设，第二个序列至少与第一个序列一样长
    + 包括那些只接受一个单一迭代器表示第二个序列的算法，都是假设第二个序列至少与第一个序列一样长



##### 2、写容器元素的算法

+ 写容器元素算法将新值赋予序列中的元素

+ 使用这种算法必须保证序列大小大于等于算法要写入的元素数目
+ fill算法
    + 前两个参数接受一对迭代器表示一个范围
    + 第三个参数是一个值
    + fill将给的的这个值赋予输入范围内的每个元素
    + 例如：fill(vec.begin()，vec.end()，0) //将每个元素置为0



+ fill_n算法
    + 接受一个单迭代器，一个计数值，一个值
    + 例如：fiil_n(vec.bagin()，vec.size()，0) //将每个元素置为0
    + 不能在空容器上调用fill_n算法
    + 向目的位置写入数据的算法假定目的位置足够大，能容纳要写入的元素



+ back_inserter
    + 定义在头文件**iterator**中
    + 插入迭代器（insert_iterator）：一种向容器中添加元素的迭代器
    + 使用插入迭代器可以保证算法有足够元素空间容纳输出元素
    + back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，例如back_inserter(vec)
    + 通过back_inserter赋值时，赋值运算符会调用push_back添加元素到容器中
    + 可以将back_inserter返回的迭代器当作目的位置，例如fill_n(back_inserter(vec)，10，0)



+ 拷贝算法（copy）
    + 向目的迭代器指向的输出序列中的元素写入数据
    + 接受三个迭代器，前两个迭代器表示输入范围，第三个迭代器表示目的序列的起始位置
    + 该算法将输入范围中的元素拷贝到目的序列中
    + 目的序列能容纳的元素至少比输入序列多
    + 可以使用copy算法实现内置数组的拷贝
    + copy返回的是目的位置迭代器的值，即copy后的数组的尾元素之后的位置



+ repalce算法
    + 该算法接受4个参数：前两个参数是迭代器，表示输入序列，第三个是要替换的值，第四个是新值
    + replace(vec.begin()，vec.end()，0，42)
    + 上面的表达式将序列中所有0替换为42
    + 如果希望原序列不变，使用replace_copy算法，该算法额外接受第三个迭代器参数
    + replace_copy(vec1.begin()，vec1.end()，back_inserter(vec2)，0，42)
    + 上述算法中，vec1并未改变，vec2含有vec1的拷贝，且0变为42



##### 3、重排容器元素的算法

+ sort算法
    + 该算法使得序列中的元素有序
    + 该算法利用元素类型的<运算符实现排序
    + sort算法接受两个迭代器，表示要排序的元素范围：sort(vec.begin()，vec.end())



+ unique算法
    + 该算法可以将序列中不重复的元素出现在容器的开头
    + unique（vec.begin()，vec.end()）
    + unique算法返回最后一个不重复元素之后的位置的的迭代器



#### 3、定制操作

提供自定义的操作替代默认运算符



##### 1、向算法传递函数

+ 谓词参数
    + 一元谓词：接受一个参数
    + 二元谓词：接受两个参数



+ 重载函数sort
    + 该函数接受第三个参数，谓词参数isShorter，该谓词参数是二元谓词
    + 该谓词替代<号比较元素



+ 稳定排序stable_sort
    + 该函数可以按字典序进行排序



##### 2、lambda表达式

+ 可以将lambda表达式理解为一个未命名的内联函数
+ lambda表达式具有一个返回类型，一个参数列表，一个函数体
+ [capture list] （parameter list） -> return type   {   function body   }
    + capture list（捕获列表）是lambda所在函数中定义的局部变量列表（通常为空）
        + 空捕获列表代表此lambda不使用它所在函数中的任何局部变量
        + lambda只能使用在捕获列表包含的局部变量
        + 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字
    + parameter list （参数列表）
    + return type （返回类型）
    + function body （函数体）
+ 与普通函数不同，lambda表达式必须使用尾置返回类型
+ 可以忽略参数列表和返回类型，但是必须有捕获列表和函数体



+ for_each算法



##### 3、lambda的捕获与返回

当定义一个lambda时，编译器会生成一个与lambda对应的新的（未命名的）类类型

即 当向一个函数传递一个lamada时，同时定义了一个新类型和该类型的一个对象

传递的参数就是此编译器生成的 类类型 的未命名对象

类似，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambada生成的类型的对象

 


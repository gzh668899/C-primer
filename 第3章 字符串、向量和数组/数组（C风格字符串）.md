## 数组（C风格字符串）



#### 在C++程序中 尽量不要使用 C风格字符串

#### C++语言中的 字符串字面值 由 C语言中的 C风格字符串 继承而来



#### C风格字符串

+ 存储在字符数组中，以空字符 '\0' 结束
+ 一般使用指针操作该字符串



#### C标准库String函数

| 函数             | 介绍                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个**正值**；如果`p1<p2`，返回一个**负值**。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

+ 这些函数定义在cstring头文件中

+ 传入这些函数的指针必须指向以空字符为结束的数组
+ 如果不是以空字符为结束，strlen函数会在内存中不断向前寻找，直到遇到空字符



#### 比较两个C风格的字符串

+ 与比较string对象不同，比较string对象只需要使用关系运算符

```c++
string s1 = "guozihan";
string s2 = "Guozihan";
if (s1 < s2) 
```



+ 如果C风格字符串使用比较运算符，只会比较指针的大小

```c++
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if(ca1 < ca2) //错误，试图比较两个无关地址
    //当使用数组时，真正用的是指向数组首元素的指针
   //因此上述if条件比较的是两个const char*的值
```



+ 如果想要比较两个C风格字符串，使用strcmp函数

```c++
if (strcmp(ca1, ca2) < 0)
```



#### 连接和拷贝两个C风格的字符串

```c++
s1 + s2 //string类型，正确
ca1 + ca2 //C风格字符串，错误，相当于两个指针相加
```



+ 连接使用 strcat函数

+ 拷贝使用 strcpy函数
+ 使用这两个函数，必须提供一个足够大的可以容纳结果字符串加上空字符的数组，充满风险
+ 因此在C++中尽量使用string类型



#### 混用string对象和C风格字符串

+ 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代
    + 允许使用以空字符结束的字符数组来**初始化string**或为string对象赋值
    + string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个对象都是）
    + string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象
+ 上面一条反过来是不可以的！！
    + 如果程序需要一个C风格字符串，无法使用string对象替代它
        + 即不能用string对象初始化指向字符的指针‘

```c++
char *str = s; //错误
const char *str = s.c_str(); //正确
```



+ string提供了一个名为c_str的成员函数
    + c_str函数的返回值是一个C风格的字符串
    + 也就是说函数的返回值是一个指针，指向以空字符结束的字符数组
    + 并且这个字符数组保存的数据与string对象中的一样
    + 结果指针（左侧指针）的类型是const char * ,确保我们不会修改字符数组中的内容
    + 无法保证返回的字符数组一直有效，如果后续改变了s的值，数组可能会失效



#### 使用数组初始化vector对象

+ 不允许数组的拷贝和赋值
+ 不允许使用vector对象初始化数组
+ 但是允许使用数组初始化vector对象
    + 只需要明确拷贝区域的首元素地址和尾后地址

```c++
int arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(arr), end(arr));
vector<int> subvec(arr+1, arr+4);
```



#### 尽量多使用vector和迭代器，少使用内置数组和指针

#### 尽量多使用string，少使用C风格的基于数组的字符串

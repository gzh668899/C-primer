## 数组（指针和数组）



#### 数组和指针具有极其紧密的关系

+ 在用到数组名字的地方，编译器会将其自动的替换成一个**指向数组首元素的指针**

```c++
string *p = &nums[0];
string *p2 = nums;  //两者等价
```



+ 数组 作为auto变量的初始值，推断得到的类型 是指针 而不是数组，详情看书

+ decltype（数组），不会发生数组到指针的转换，详情看书



#### 指针也是迭代器

+ **指针之于迭代器，就像数组之于vector**
+ **vector和string迭代器支持的运算，数组的指针全部支持**
    + 使用递增运算符移动数组元素的指针
    + 使用指针遍历数组中的元素
        + 需要获取数组中第一个元素的指针和数组尾元素下一位位置的指针
        + 如何获取呢？使用标准库函数begin和end



#### 标准库函数begin和end（C++11新标准）

+ 这两个函数定义在iterator头文件中

    ```c++
    int ia[];
    int *beg = begin(ia); //指向ia首元素的指针
    int *last = end(ia); //指向ia尾元素下一位置的指针
    int n = end(ia) - begin(ia) //n是数组中元素的数量
    ```

+ 因为数组不是类类型，因此这俩函数不是成员函数，需要将数组作为函数的参数来使用这俩函数

+ 特别注意：尾后指针不能指向解引用和递增操作



#### 指针的运算

+ 指针可以指向迭代器所支持的所有运算

| 运算符           | 解释                                   |
| ---------------- | -------------------------------------- |
| `*iter`          | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem`      | 等价于`(*iter).mem`                    |
| `++iter`         | 令`iter`指示容器中的下一个元素         |
| `--iter`         | 令`iter`指示容器中的上一个元素         |
| `iter1 == iter2` | 判断两个迭代器是否相等                 |

| 运算符               | 解释                                                         |
| -------------------- | ------------------------------------------------------------ |
| `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n`           | 迭代器减去一个整数值仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
| `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
| `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符                                           |



+ 两个指针相减的结果的类型是ptrdiff_t的类型
    + 与size_t类型一样，定义在cstddef头文件中，与机器无关
    + 差值可能是负值，因此是带符号类型



+ 两个指针必须指向相关的对象，比如同一个数组，否则不能进行比较





#### 解引用与指针运算的交互

```c
int ia[] = {0, 2, 4, 6, 8};
int last = *（ia + 4）; 

//*(ia + 4)等价于ia[4]
//括号必不可少，*ia + 4指的是ia[0] + 4
```



#### 下标和指针

+ 对数组执行下标运算，其实是 **对指向数组元素的指针** 进行下标运算

+ 数组内置的下标运算符可以处理负值

+ vector和string所使用的下标不能处理负值，必须是无符号类型

    ```c++
    int ia[] = {0, 2, 4, 6, 8};
    int *p = &ia[2];
    int j = p[1]; //等价于*(p + 1)，即ia[3]
    int k = p[-2]; //等价于*(p - 2),即ia[0]
    
    //总结，数组的下标运算，其实是指针的加减运算，再解引用
    ```

    

